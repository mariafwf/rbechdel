---
title: "Project 1"
author: "Maria Figueiredo"
toc: true
number-sections: true
highlight-style: pygments
format:
  html
---

```{r}
library(dplyr)
library(tidyverse, warn.conflicts = FALSE)
```

```{r}
movies <- read.csv("movies.csv")
```

```{r}
#glimpse(movies)
```

# clean

```{r warning=FALSE}
movies <- movies |>
  subset(select = -c(imdb_id, error, poster, type, imdb, imdb_votes,
                  code, period_code, decade_code, released, response, runtime))
```

```{r}
#movies
```
We can convert the variables into factor

Furthermore, we can also extract the most 
The `clean_test` variable gives us the reasons why a certain movie failed the Bechdel Test. We can use the `count()` function to extract all possible values.

```{r}
movies |>
  count(clean_test)
```
Here, `nowomen` includes movies that had no women in them (rating 0), `notalk` includes movies that had women in them, but they did not talk to each other (rating 1), and `men` includes movies that had women that talked to each other, but only about men (rating 2). The tag `dubious` is given to those movies that have caused some skepticism about whether they pass the test, but have ultimately received the FAIL label.

```{r}
movies |>
  group_by(clean_test) |>
  count(binary)
```


We can check the accuracy of those designations by cross-referencing them with the columns `binary`, which reduces the classification to PASS/FAIL according to the Bechdel Test conditions.



In contrast, `ok` denotes movies that passed the Bechdel Test without a doubt, and `dubious` refers to movies that also passed the test, albeit some raters might have been skeptical about it. We can confirm these 

```{r}
movies |>
  filter(clean_test %in% c("ok")) |>
  count(binary)
```



# general frequency trends
# distribution by release year

```{r}
movies |>
  group_by(year) |>
  count() |>
  ggplot() + geom_line(aes(year, n, group = 1))
```

```{r}
library(lattice)
library(udpipe)
```


```{r}
udmodel <- udpipe_load_model(file = 'english-ewt-ud-2.5-191206.udpipe')
s <- udpipe_annotate(udmodel, movies$plot)
x <- data.frame(s)
stats <- txt_freq(x$upos)
stats$key <- factor(stats$key, levels = rev(stats$key))
```

```{r}
## NOUNS
stats <- subset(x, upos %in% c("NOUN")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "cadetblue", 
         main = "Most occurring nouns", xlab = "Freq")
```
```{r}
## ADJECTIVES
stats <- subset(x, upos %in% c("ADJ")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "purple", 
         main = "Most occurring adjectives", xlab = "Freq")
```

```{r}
## VERBS
stats <- subset(x, upos %in% c("VERB")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "gold", 
         main = "Most occurring Verbs", xlab = "Freq")
```
```{r}
## Using RAKE
stats <- keywords_rake(x = x, term = "lemma", group = "doc_id", 
                       relevant = x$upos %in% c("NOUN", "ADJ"))
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ rake, data = head(subset(stats, freq > 3), 20), col = "red", 
         main = "Keywords identified by RAKE", 
         xlab = "Rake")
```

```{r}
## Using a sequence of POS tags (noun phrases / verb phrases)
x$phrase_tag <- as_phrasemachine(x$upos, type = "upos")
stats <- keywords_phrases(x = x$phrase_tag, term = tolower(x$token), 
                          pattern = "(A|N)*N(P+D*(A|N)*N)*", 
                          is_regex = TRUE, detailed = FALSE)
stats <- subset(stats, ngram > 1 & freq > 3)
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ freq, data = head(stats, 20), col = "magenta", 
         main = "Keywords - simple noun phrases", xlab = "Frequency")
```
This classification can be used 
imdb score
plot keywords
genre