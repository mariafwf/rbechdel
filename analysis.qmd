---
title: "Project 1"
author: "Maria Figueiredo"
toc: true
number-sections: true
highlight-style: pygments
format:
  html
---

# Imports

```{r}
#| warning: false
library(dplyr)
library(tidyverse)
library(tibble)
```

```{r}
movies <- read.csv("movies.csv")
```

# Data Cleaning

We start the process by cleaning our dataset so that our analysis can flow more easily, without unnecessary variables getting in the way. Some columns such as `imdb_id`, `code`, `period_code`, and `decade_code` store more organizational variables that won't necessarily be important when we look at relationships between more relevant variables. Other columns simply contain too much unique data. `actors`, for instance, includes names of all starring actors in a single cell. We can filter some of these columns out with the `subset()` function.

```{r}
#| warning: false
movies <- movies |>
  subset(select = -c(imdb_id, error, poster, type, awards,
                     imdb_votes, code, period_code, imdb,
                     released, response, runtime, decade_code,
                     actors, writer, director))
```

```{r}
glimpse(movies)
```
Additionally, some columns have many `N/A` values that might complicate our analysis later. We can get rid of those as well using `drop_na()`.

```{r}
movies <- movies |>
  drop_na()
```

# Bechdel Ratings

The `clean_test` variable gives us the reasons why a certain movie failed the Bechdel Test. We can use the `count()` function to extract all possible values.

```{r}
movies |>
  count(clean_test)
```
Here, `nowomen` includes movies that had no women in them (rating 0), `notalk` includes movies that had women in them, but they did not talk to each other (rating 1), and `men` includes movies that had women that talked to each other, but only about men (rating 2). The tag `dubious` is given to those movies that caused some skepticism about whether or not they pass the test, but ultimately received the `FAIL` label. In contrast, `ok` denotes movies that met all three conditions and thus passed the Bechdel Test.

We can check the accuracy of those designations by cross-referencing them with the columns `binary`, which reduces the classification to `PASS/FAIL` according to the Bechdel Test conditions.

```{r}
movies |>
  group_by(clean_test) |>
  count(binary)
```
While the labels certainly help us understand the reasons behind each failure, they are not the easiest data to work with. The `mutate` function can help us convert the labels into numerical values within [0,3], according to the Bechdel rule. Since `dubious` does not fall into a specific category, we will convert it into an additional `-1` rating level for the time being These values are then stored into a new column named `rating`.

```{r}
movies['rating'] <- 0
movies <- movies |>
  mutate(rating = case_when(
    clean_test == 'dubious' ~ -1,
    clean_test == 'nowomen' ~ 0,
    clean_test == 'notalk' ~ 1,
    clean_test == 'men' ~ 2,
    clean_test == 'ok' ~ 3)
  )
```

```{r}
glimpse(movies)
```

For an added layer of organization, we can also categorize the ratings as different levels with the `as.factor()` function.

```{r}
movies['rating_fac'] <- as.factor(movies$rating)
movies$rating_fac
```

# Analysis & Visualization

Now that we have a clean dataset with only relevant columns, we can analyze general trends of the Bechdel test in relation to other variables. At this point, we can already generate some interesting plots.

## Yearly Trends

The next code chunk creates a line graph that shows how the mean rating for the Bechdel test changed over the analyzed years. This is one of the many relationships that can be explored in the data.

```{r}
movies |>
  group_by(year) |>
  mutate(avg = mean(rating, na.rm = TRUE)) |>
  ungroup() |>
  ggplot() + geom_line(aes(year, avg))
```

## Subsetting

Furthermore, since we will be often looking at the different rating levels, it might be helpful to create separate sub-dataframes for each of them. We will leave the `dubious` label out of our analysis, since it is not entirely defined.

```{r}
filter(movies, rating_fac == 0) -> bechdel_0
filter(movies, rating_fac == 1) -> bechdel_1
filter(movies, rating_fac == 2) -> bechdel_2
filter(movies, rating_fac == 3) -> bechdel_3
```


## International Gross 

As an example, we can analyze possible correlations between a movie's international gross, normalized to 2013, and its result on the Bechdel test. In order to do so, one option would be to calculate the mean gross for each level of rating. Note that the international gross normalized to 2013 is represented by the variable `intgross_2013`.

We first create a new dataset to store the ratings, as well as their respective gross mean values. Since the variable is not numeric in the original dataframe, we can convert it using `as.integer()`.

```{r}
#| warning: false
intgross <- data.frame(rating = c(0, 1, 2, 3),
                mean = c(mean(as.integer(bechdel_0$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_1$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_2$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_3$intgross_2013), na.rm = TRUE))
                )
```

We can plot the values in a simple bar chart with `ggplot`. The plot reveals that movies with at least two women in them who do not talk to each other had the highest mean international gross value, receiving a rating of 1, followed by those that had no women characters, meaning they failed the Bechdel test.

```{r}
intgross |>
  ggplot(aes(x = rating, y = mean)) +
    geom_bar(stat = "identity") +
    coord_flip()
```
Another way we could look at the relationship between the two variables is to look at the frequency of ratings for highest-grossing movies. A subset of size `n = 80` was chosen arbitrarily for this step. First, we use `order()` to sort the data in a descending order based on the `intgross_2013` variable.

```{r}
#| warning: false
movies <- movies[order(as.integer(movies$intgross_2013), decreasing = TRUE),]
```
Then, we extract the first 80 columns, or the 80 highest-grossing movies, with the help of the `head()` function. We can plot the frequencies of each Bechdel rating using `geom_histogram()`. Here, we observe that most of the highest-grossing movies in the dataset had a rating of 1 (women who don't talk), followed by 3 (passed the test).

```{r}
movies |>
  head(80) |>
  ggplot(aes(x = as.integer(rating))) +
    geom_histogram(binwidth = 1)
```

## Genre

A further example of a relationship that can be analyzed is that between the genre of a movie and its `PASS/FAIL` Bechdel designation. When trying to extract the values for genre, we run into a problem. Some movies fall into multiple genre categories and have therefore more than a single one listed. There are multiple ways to approach this. The easiest option would be to only look at the first value. However, the genres are listed in alphabetical order, with no actual levels of "importance." Thus, ignoring the rest would not be representative of all genres. In this case, `str_split_i()` can come in handy.

```{r}
?str_split
```

The function allows us to split a string into pieces. The names in the `genre` column are separated by a simple comma (,), which could serve as our `pattern` parameter. We can split the `genre` string into 3 values, since 3 is the maximum number of genres listed, and instead add them to separate columns `genre_1`, `genre_2`, and `genre_3`.

```{r}
movies['genre_1'] <- 'NA'
movies['genre_2'] <- 'NA'
movies['genre_3'] <- 'NA'

for(i in 1:nrow(movies)) {
  movies[i, 'genre_1'] <- str_split_i(movies[i, "genre"], ", ", 1)
  movies[i, 'genre_2'] <- str_split_i(movies[i, "genre"], ", ", 2)
  movies[i, 'genre_3'] <- str_split_i(movies[i, "genre"], ", ", 3)
}
```

```{r}
glimpse(movies)
```

At this point, we have all listed genres separately, in different columns. Still, it would be more helpful for the purpose of our analysis to put those values in a single column, i.e. make the dataframe "longer". We can easily achieve this with `pivot_longer`.

```{r}
movies <- movies |>
  pivot_longer(cols = c('genre_1', 'genre_2', 'genre_3'),
               names_to = 'genre_labels',
               values_to = 'genres')

glimpse(movies)
```
Notice that some rows still contain `NA` values, since not all movies have three different genres. Again, we can ignore those values. Likewise, we won't be needing our `genre_labels` column, so we can filter that out as well.

```{r}
movies <- movies |>
  drop_na() |>
  subset(select = -c(genre_labels))
  
glimpse(movies)
```

```{r}
movies |>
  group_by(genres) |>
  count(binary)
```



## Joining Datasets

As we have seen before with the existence of a `dubious` variable, the Bechdel test is not always a consensus between viewers. That is because they might have different notions of what it means for a movie to have a woman with a significant enough role to be factored into the test, or there might be nuances to a conversation between women that viewers may or may not classify as "about a a man." In order to explore this variation even further, we will import `raw_bechdel.csv`, a different dataset that includes some information about movies from 1970 to 2020. 

```{r}
raw_bechdel <- read.csv("raw_bechdel.csv")
```

For the sake of simplicity, we will assume that rows where the `title` and `year` variables are the same in both dataframes refer to the same movie. We can join both dataframes by `title` with `left_join()`, then select the duplicates that have the same `year`.

```{r}
#| warning: false
joined <- movies |>
  left_join(raw_bechdel, by = "title") |>
  filter(year.x == year.y) |>
  rename("year" = `year.x`)
```

Using the `sum()` function, we observe that the ratings given to overlapping movies in both datasets are the same in 3184 occasions. In contrast, they are not the same in 455 occasions, 444 of them being cases where the rating in `raw_bechdel` is greater than that in `movies`.

```{r}
sum(joined$rating.x == joined$rating.y)
sum(joined$rating.x != joined$rating.y)
sum(joined$rating.x > joined$rating.y)
sum(joined$rating.x < joined$rating.y)
```
# Keywords (with NLP tokenization)

This next section utilizes the UDPipe package, an open-source tool for Natural Language Processing, including tokenization, raw text parsing, and tagging.

```{r}
library(lattice)
library(udpipe)
```

```{r}
udmodel <- udpipe_load_model(file = 'english-ewt-ud-2.5-191206.udpipe')
s <- udpipe_annotate(udmodel, movies$plot)
x <- data.frame(s)
stats <- txt_freq(x$upos)
stats$key <- factor(stats$key, levels = rev(stats$key))
```

```{r}
## NOUNS
stats <- subset(x, upos %in% c("NOUN")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "cadetblue", 
         main = "Most occurring nouns", xlab = "Freq")
```
```{r}
## ADJECTIVES
stats <- subset(x, upos %in% c("ADJ")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "purple", 
         main = "Most occurring adjectives", xlab = "Freq")
```

```{r}
## VERBS
stats <- subset(x, upos %in% c("VERB")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "gold", 
         main = "Most occurring Verbs", xlab = "Freq")
```
```{r}
## Using RAKE
stats <- keywords_rake(x = x, term = "lemma", group = "doc_id", 
                       relevant = x$upos %in% c("NOUN", "ADJ"))
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ rake, data = head(subset(stats, freq > 3), 20), col = "red", 
         main = "Keywords identified by RAKE", 
         xlab = "Rake")
```

```{r}
## Using a sequence of POS tags (noun phrases / verb phrases)
x$phrase_tag <- as_phrasemachine(x$upos, type = "upos")
stats <- keywords_phrases(x = x$phrase_tag, term = tolower(x$token), 
                          pattern = "(A|N)*N(P+D*(A|N)*N)*", 
                          is_regex = TRUE, detailed = FALSE)
stats <- subset(stats, ngram > 1 & freq > 3)
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ freq, data = head(stats, 20), col = "magenta", 
         main = "Keywords - simple noun phrases", xlab = "Frequency")
```