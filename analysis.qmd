---
title: "Project 1"
author: "Maria Figueiredo"
toc: true
number-sections: true
highlight-style: pygments
format:
  html
---

# Imports

```{r}
#| warning: false
library(dplyr)
library(tidyverse)
library(tibble)
```

```{r}
movies <- read.csv("movies.csv")
```

# Data Cleaning

We start the process by cleaning our dataset so that our analysis can flow more easily, without unnecessary variables getting in the way. Some columns such as `imdb_id`, `code`, `period_code`, and `decade_code` store more organizational variables that won't necessarily be important when we look at relationships between more relevant variables. Other columns simply contain too much unique data. `actors`, for instance, includes names of all starring actors in a single cell. We can filter some of these columns out with the `subset()` function.

```{r}
#| warning: false
movies <- movies |>
  subset(select = -c(imdb_id, error, poster, type, awards,
                     imdb_votes, code, period_code, imdb,
                     released, response, runtime, decade_code,
                     actors, writer, director))
```

```{r}
glimpse(movies)
```
Additionally, some columns have many `N/A` values that might complicate our analysis later. We can get rid of those as well using `drop_na()`.

```{r}
movies <- movies |>
  drop_na()
```

# Bechdel Ratings

The `clean_test` variable gives us the reasons why a certain movie failed the Bechdel Test. We can use the `count()` function to extract all possible values.

```{r}
movies |>
  count(clean_test)
```
Here, `nowomen` includes movies that had no women in them (rating 0), `notalk` includes movies that had women in them, but they did not talk to each other (rating 1), and `men` includes movies that had women that talked to each other, but only about men (rating 2). The tag `dubious` is given to those movies that caused some skepticism about whether or not they pass the test, but ultimately received the `FAIL` label. In contrast, `ok` denotes movies that met all three conditions and thus passed the Bechdel Test.

We can check the accuracy of those designations by cross-referencing them with the columns `binary`, which reduces the classification to `PASS/FAIL` according to the Bechdel Test conditions.

```{r}
movies |>
  group_by(clean_test) |>
  count(binary)
```
While the labels certainly help us understand the reasons behind each failure, they are not the easiest data to work with. The `mutate` function can help us convert the labels into numerical values within [0,3], according to the Bechdel rule. Since `dubious` does not fall into a specific category, we will convert it into an additional `-1` rating level for the time being These values are then stored into a new column named `rating`.

```{r}
movies['rating'] <- 0
movies <- movies |>
  mutate(rating = case_when(
    clean_test == 'dubious' ~ -1,
    clean_test == 'nowomen' ~ 0,
    clean_test == 'notalk' ~ 1,
    clean_test == 'men' ~ 2,
    clean_test == 'ok' ~ 3)
  )
```

```{r}
glimpse(movies)
```

For an added layer of organization, we can also categorize the ratings as different levels with the `as.factor()` function.

```{r}
movies['rating_fac'] <- as.factor(movies$rating)
movies$rating_fac
```

# Analysis & Visualization

Now that we have a clean dataset with only relevant columns, we can analyze general trends of the Bechdel test in relation to other variables. At this point, we can already generate some interesting plots.

## Yearly Trends

The next code chunk creates a line graph that shows how the mean rating for the Bechdel test changed over the analyzed years. This is one of the many relationships that can be explored in the data.

```{r}
movies |>
  group_by(year) |>
  mutate(avg = mean(rating, na.rm = TRUE)) |>
  ungroup() |>
  ggplot() + geom_line(aes(year, avg))
```

## Subsetting

Furthermore, since we will be often looking at the different rating levels, it might be helpful to create separate sub-dataframes for each of them. We will leave the `dubious` label out of our analysis, since it is not entirely defined.

```{r}
filter(movies, rating_fac == 0) -> bechdel_0
filter(movies, rating_fac == 1) -> bechdel_1
filter(movies, rating_fac == 2) -> bechdel_2
filter(movies, rating_fac == 3) -> bechdel_3
```


## International Gross 

As an example, we can analyze possible correlations between a movie's international gross, normalized to 2013, and its result on the Bechdel test. In order to do so, one option would be to calculate the mean gross for each level of rating. Note that the international gross normalized to 2013 is represented by the variable `intgross_2013`.

We first create a new dataset to store the ratings, as well as their respective gross mean values. Since the variable is not numeric in the original dataframe, we can convert it using `as.integer()`.

```{r}
#| warning: false
intgross <- data.frame(rating = c(0, 1, 2, 3),
                mean = c(mean(as.integer(bechdel_0$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_1$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_2$intgross_2013), na.rm = TRUE),
                         mean(as.integer(bechdel_3$intgross_2013), na.rm = TRUE))
                )
```

We can plot the values in a simple bar chart with `ggplot`. The plot reveals that movies with at least two women in them who do not talk to each other had the highest mean international gross value, receiving a rating of 1, followed by those that had no women characters, meaning they failed the Bechdel test.

```{r}
intgross |>
  ggplot(aes(x = rating, y = mean)) +
    geom_bar(stat = "identity") +
    coord_flip()
```
Another way we could look at the relationship between the two variables is to look at the frequency of ratings for highest-grossing movies. A subset of size `n = 80` was chosen arbitrarily for this step. First, we use `order()` to sort the data in a descending order based on the `intgross_2013` variable.

```{r}
movies <- movies[order(as.integer(movies$intgross_2013), decreasing = TRUE),]
```
Then, we extract the first 80 columns, or the 80 highest-grossing movies, with the help of the `head()` function. We can plot the frequencies of each Bechdel rating using `geom_histogram()`. Here, we observe that most of the highest-grossing movies in the dataset had a rating of 1 (women who don't talk), followed by 3 (passed the test).

```{r}
movies |>
  head(80) |>
  ggplot(aes(x = as.integer(rating))) +
    geom_histogram(binwidth = 1)
```

## Genre

A further example of a relationship that can be analyzed is that between the genre of a movie and its `PASS/FAIL` Bechdel designation. When trying to extract the values for genre, we run into a problem. Some movies fall into multiple genre categories and have therefore more than a single one listed. There are multiple ways to approach this. The easiest option would be to only look at the first value. However, the genres are listed in alphabetical order, with no actual levels of "importance." Thus, ignoring the rest would not be representative of all genres. In this case, the `str_split()` function can come in handy.

```{r}
?str_split
```

The name in the `genre` column are separated by a simple comma (,), which could serves as our `pattern` parameter.

```{r}
movies['genre_1'] <- 'NA'
movies['genre_2'] <- 'NA'
movies['genre_3'] <- 'NA'

for(i in 1:nrow(movies)) {
  str_split(movies[i, "genre"], ",")
}
```



## Keywords with NLP

```{r}
library(lattice)
library(udpipe)
```


This next section utilizes the UDPipe package, an open-source tool for Natural Language Processing, including tokenization, raw text parsing, and tagging.

```{r}
udmodel <- udpipe_load_model(file = 'english-ewt-ud-2.5-191206.udpipe')
s <- udpipe_annotate(udmodel, movies$plot)
x <- data.frame(s)
stats <- txt_freq(x$upos)
stats$key <- factor(stats$key, levels = rev(stats$key))
```

```{r}
## NOUNS
stats <- subset(x, upos %in% c("NOUN")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "cadetblue", 
         main = "Most occurring nouns", xlab = "Freq")
```
```{r}
## ADJECTIVES
stats <- subset(x, upos %in% c("ADJ")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "purple", 
         main = "Most occurring adjectives", xlab = "Freq")
```

```{r}
## VERBS
stats <- subset(x, upos %in% c("VERB")) 
stats <- txt_freq(stats$token)
stats$key <- factor(stats$key, levels = rev(stats$key))
barchart(key ~ freq, data = head(stats, 20), col = "gold", 
         main = "Most occurring Verbs", xlab = "Freq")
```
```{r}
## Using RAKE
stats <- keywords_rake(x = x, term = "lemma", group = "doc_id", 
                       relevant = x$upos %in% c("NOUN", "ADJ"))
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ rake, data = head(subset(stats, freq > 3), 20), col = "red", 
         main = "Keywords identified by RAKE", 
         xlab = "Rake")
```

```{r}
## Using a sequence of POS tags (noun phrases / verb phrases)
x$phrase_tag <- as_phrasemachine(x$upos, type = "upos")
stats <- keywords_phrases(x = x$phrase_tag, term = tolower(x$token), 
                          pattern = "(A|N)*N(P+D*(A|N)*N)*", 
                          is_regex = TRUE, detailed = FALSE)
stats <- subset(stats, ngram > 1 & freq > 3)
stats$key <- factor(stats$keyword, levels = rev(stats$keyword))
barchart(key ~ freq, data = head(stats, 20), col = "magenta", 
         main = "Keywords - simple noun phrases", xlab = "Frequency")
```
This classification can be used 
imdb score
plot keywords
genre